<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è | –ó–∞–¥—É–π —Å–≤—ñ—á–∫—É</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÇ</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      overflow: hidden;
      font-family: 'Arial', 'Segoe UI', system-ui, sans-serif;
      color: #333;
    }
    #video, #canvas, #confettiCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }
    #confettiCanvas { z-index: 60; pointer-events: none; }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #ff6b95;
      font-size: clamp(18px, 4vw, 24px);
      text-align: center;
      padding: 20px;
      gap: 20px;
    }
    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 107, 149, 0.3);
      border-top: 4px solid #ff6b95;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    #loading p {
      color: #666;
      font-size: clamp(14px, 3vw, 18px);
      max-width: 300px;
      line-height: 1.4;
    }

    #wishText {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      color: #ff6b95;
      padding: 15px 25px;
      border-radius: 20px;
      font-size: 1.3em;
      font-weight: bold;
      z-index: 85;
      text-align: center;
      border: 3px solid #ffb6c1;
      display: none;
      max-width: 80%;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(10px);
    }

    #handIndicator {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      color: #ff6b95;
      padding: 12px 20px;
      border-radius: 20px;
      border: 2px solid rgba(255, 182, 193, 0.5);
      display: none;
      align-items: center;
      gap: 10px;
      z-index: 99;
      font-size: 16px;
      font-weight: bold;
    }
    .indicator.show { 
      display: flex; 
      animation: slideDown 0.3s ease; 
    }

    #flameStatus {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 107, 107, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      z-index: 100;
      display: none;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    #micBtn {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(20px);
      border: 3px solid #ff6b95;
      color: #ff6b95;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(255, 107, 149, 0.3);
    }
    #micBtn:hover { 
      transform: translateX(-50%) scale(1.1); 
      background: white;
    }

    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); } 
    }
    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div id="loadingText">üéÇ –ì–æ—Ç—É—î–º–æ —Ç–æ—Ä—Ç...</div>
    <p>–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏ —Ç–∞ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>
  <canvas id="confettiCanvas"></canvas>

  <div id="wishText">üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è —Ç–∞ –∑–∞–¥—É–π —Å–≤—ñ—á–∫—É! üí®</div>

  <div id="flameStatus">üî• –ü–æ–ª—É–º'—è –ø–∞–ª–∞—î</div>

  <div id="handIndicator" class="indicator">
    <span>üëã</span>
    <span>–ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</span>
  </div>

  <button id="micBtn" aria-label="–ú—ñ–∫—Ä–æ—Ñ–æ–Ω">üé§</button>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    const CONFIG = {
      SMOOTHING_FACTOR: 0.7,
      HAND_NOT_DETECTED_THRESHOLD: 10,
      PALM_SCALE_FACTOR: 0.8,
      MIN_CAKE_SIZE: 100,
      MAX_CAKE_SIZE: 250,
      FLAME_BLOWOUT_THRESHOLD: 0.5
    };

    const state = {
      lastLandmarks: null,
      smoothedLandmarks: null,
      handNotDetectedCount: 0,
      animationFrameId: null,
      palmCenter: { x: 0, y: 0 },
      palmSize: 1.0,
      isFlameLit: true,
      isMicActive: false,
      audioContext: null,
      analyser: null,
      microphone: null,
      dataArray: null,
      isAudioUnlocked: false,
      isCakeVisible: false
    };

    const elements = {
      video: document.getElementById("video"),
      canvas: document.getElementById("canvas"),
      confettiCanvas: document.getElementById("confettiCanvas"),
      loading: document.getElementById("loading"),
      loadingText: document.getElementById("loadingText"),
      micBtn: document.getElementById("micBtn"),
      handIndicator: document.getElementById("handIndicator"),
      wishText: document.getElementById("wishText"),
      flameStatus: document.getElementById("flameStatus")
    };

    const confettiCtx = elements.confettiCanvas.getContext("2d");
    let confetti = [];

    // –ê—É–¥—ñ–æ - —Å—Ç–≤–æ—Ä—é—î–º–æ —á–µ—Ä–µ–∑ Web Audio API –¥–ª—è –∫—Ä–∞—â–æ—ó —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
    let audioBlow, audioCelebration;

    let scene, camera, renderer;
    let cakeMesh, candleMesh, flameMesh, flameLight;
    let cakeTexture;
    let handLandmarker;

    class CakeARApplication {
      constructor() { 
        this.init(); 
      }

      async init() {
        try {
          this.setupEventListeners();
          await this.setupCamera();
          await this.initWebGL();
          await this.setupHandTracking();
          await this.loadCakeTexture();
          this.setupAudio();
          this.hideLoading();
          this.startRenderLoop();
          this.unlockAudio();
        } catch (error) {
          this.handleError(error);
        }
      }

      unlockAudio() {
        const unlock = () => {
          if (state.isAudioUnlocked) return;
          state.isAudioUnlocked = true;
          document.removeEventListener('click', unlock);
          document.removeEventListener('touchstart', unlock);
        };
        document.addEventListener('click', unlock, { once: true });
        document.addEventListener('touchstart', unlock, { once: true });
      }

      setupAudio() {
        if (!state.audioContext) {
          state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –∞—É–¥—ñ–æ –±—É—Ñ–µ—Ä–∏ –¥–ª—è –∑–≤—É–∫—ñ–≤
        this.createAudioBuffers();
      }

      async createAudioBuffers() {
        // –ü—Ä–æ—Å—Ç—ñ –∑–≤—É–∫–∏ —á–µ—Ä–µ–∑ –æ—Å—Ü–∏–ª—è—Ç–æ—Ä–∏
        // –ú–æ–∂–Ω–∞ –∑–∞–º—ñ–Ω–∏—Ç–∏ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ñ –∑–≤—É–∫–æ–≤—ñ —Ñ–∞–π–ª–∏
      }

      async initMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            } 
          });
          
          state.microphone = state.audioContext.createMediaStreamSource(stream);
          state.analyser = state.audioContext.createAnalyser();
          state.analyser.fftSize = 2048;
          state.analyser.smoothingTimeConstant = 0.3;
          state.microphone.connect(state.analyser);
          state.dataArray = new Uint8Array(state.analyser.frequencyBinCount);
          
          state.isMicActive = true;
          elements.micBtn.style.background = '#ff6b95';
          elements.micBtn.style.color = 'white';
          
          this.analyzeMicrophone();
          
        } catch (error) {
          console.error('Microphone error:', error);
          alert('–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞');
        }
      }

      analyzeMicrophone() {
        if (!state.isMicActive || !state.analyser || !state.isFlameLit) return;
        
        state.analyser.getByteFrequencyData(state.dataArray);
        let sum = 0;
        for (let i = 0; i < state.dataArray.length; i++) {
          sum += state.dataArray[i];
        }
        const avg = sum / state.dataArray.length;
        const volume = Math.min(1, avg / 128);
        
        if (volume > CONFIG.FLAME_BLOWOUT_THRESHOLD && state.isFlameLit) {
          this.blowOutCandle();
        }
        
        if (state.isFlameLit && flameMesh) {
          const flicker = 1 + Math.sin(Date.now() * 0.01) * 0.1 + volume * 0.2;
          flameMesh.scale.set(flicker, flicker, flicker);
          
          const hue = 20 + volume * 10;
          flameMesh.material.color.setHSL(hue/360, 1, 0.5);
        }
        
        requestAnimationFrame(() => this.analyzeMicrophone());
      }

      stopMicrophone() {
        if (state.microphone && state.microphone.mediaStream) {
          state.microphone.mediaStream.getTracks().forEach(track => track.stop());
        }
        state.isMicActive = false;
        state.analyser = null;
        state.microphone = null;
        elements.micBtn.style.background = 'rgba(255, 255, 255, 0.9)';
        elements.micBtn.style.color = '#ff6b95';
      }

      setupEventListeners() {
        elements.micBtn.addEventListener('click', () => this.toggleMicrophone());
        window.addEventListener('resize', () => this.handleResize());
        window.addEventListener('beforeunload', () => this.cleanup());
      }

      async setupCamera() {
        try {
          const constraints = { 
            video: { 
              facingMode: "environment", 
              width: { ideal: 1280 }, 
              height: { ideal: 720 }, 
              frameRate: { ideal: 30 } 
            } 
          };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          elements.video.srcObject = stream;
          await new Promise(r => { 
            elements.video.onloadedmetadata = () => { 
              elements.video.play(); 
              r(); 
            }; 
          });
        } catch (error) {
          console.error('Camera setup failed:', error);
          throw new Error('CAMERA_ERROR');
        }
      }

      async initWebGL() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(
          -window.innerWidth / 2, 
          window.innerWidth / 2, 
          window.innerHeight / 2, 
          -window.innerHeight / 2, 
          0.1, 
          1000
        );
        camera.position.z = 10;
        
        renderer = new THREE.WebGLRenderer({ 
          canvas: elements.canvas, 
          alpha: true, 
          antialias: true, 
          powerPreference: "high-performance" 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // –î–æ–¥–∞–º–æ –±–∞–∑–æ–≤–µ –æ—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        this.createCake();
        this.createCandle();
      }

      createCake() {
        const geometry = new THREE.CylinderGeometry(1, 1.2, 0.3, 32);
        const material = new THREE.MeshPhongMaterial({ 
          color: 0xffffff,
          shininess: 30,
          transparent: true,
          side: THREE.DoubleSide
        });
        cakeMesh = new THREE.Mesh(geometry, material);
        cakeMesh.visible = false;
        scene.add(cakeMesh);
      }

      createCandle() {
        // –°–≤—ñ—á–∫–∞
        const candleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 16);
        const candleMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xffffff,
          shininess: 100
        });
        candleMesh = new THREE.Mesh(candleGeometry, candleMaterial);
        candleMesh.position.y = 0.2;
        candleMesh.visible = false;
        
        // –ü–æ–ª—É–º'—è
        const flameGeometry = new THREE.ConeGeometry(0.08, 0.2, 16);
        const flameMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xff4500,
          emissive: 0xff4500,
          emissiveIntensity: 0.5,
          transparent: true,
          opacity: 0.9
        });
        flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
        flameMesh.position.y = 0.45;
        flameMesh.visible = false;
        
        // –°–≤—ñ—Ç–ª–æ –≤—ñ–¥ –ø–æ–ª—É–º'—è
        flameLight = new THREE.PointLight(0xff4500, 1, 5);
        flameLight.position.y = 0.45;
        flameLight.visible = false;
        
        scene.add(candleMesh);
        scene.add(flameMesh);
        scene.add(flameLight);
      }

      async setupHandTracking() {
        try {
          const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
          );
          handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { 
              modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", 
              delegate: "GPU" 
            },
            runningMode: "VIDEO",
            numHands: 1
          });
        } catch (error) {
          console.error('Hand tracking setup failed:', error);
          throw error;
        }
      }

      async loadCakeTexture() {
        return new Promise((resolve) => {
          const textureLoader = new THREE.TextureLoader();
          textureLoader.load(
            'foto.png',
            (texture) => {
              cakeTexture = texture;
              cakeTexture.minFilter = THREE.LinearFilter;
              cakeTexture.magFilter = THREE.LinearFilter;
              if (cakeMesh && cakeMesh.material) {
                cakeMesh.material.map = cakeTexture;
                cakeMesh.material.needsUpdate = true;
              }
              resolve();
            },
            undefined,
            () => {
              // –Ø–∫—â–æ —Ñ–∞–π–ª –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ, —Å—Ç–≤–æ—Ä—é—î–º–æ –ø—Ä–æ—Å—Ç—É —Ç–µ–∫—Å—Ç—É—Ä—É
              console.log('Creating fallback cake texture');
              const canvas = document.createElement('canvas');
              canvas.width = 256; 
              canvas.height = 256;
              const ctx = canvas.getContext('2d');
              const gradient = ctx.createLinearGradient(0, 0, 256, 256);
              gradient.addColorStop(0, '#ff9a9e');
              gradient.addColorStop(1, '#fad0c4');
              ctx.fillStyle = gradient;
              ctx.fillRect(0, 0, 256, 256);
              ctx.fillStyle = 'white';
              ctx.font = 'bold 48px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('üéÇ', 128, 150);
              
              cakeTexture = new THREE.CanvasTexture(canvas);
              if (cakeMesh && cakeMesh.material) {
                cakeMesh.material.map = cakeTexture;
                cakeMesh.material.needsUpdate = true;
              }
              resolve();
            }
          );
        });
      }

      startRenderLoop() {
        const render = () => {
          this.detectHands();
          this.updateCakePosition();
          this.updateConfetti();
          
          // –ê–Ω—ñ–º–∞—Ü—ñ—è –ø–æ–ª—É–º'—è
          if (state.isFlameLit && flameMesh && state.isCakeVisible) {
            const time = Date.now() * 0.001;
            flameMesh.position.y = 0.45 + Math.sin(time * 5) * 0.02;
            flameMesh.scale.x = flameMesh.scale.y = 1 + Math.sin(time * 8) * 0.1;
            if (flameLight) {
              flameLight.intensity = 0.8 + Math.sin(time * 6) * 0.2;
            }
          }
          
          // –†–µ–Ω–¥–µ—Ä —Å—Ü–µ–Ω–∏
          if (renderer && scene && camera) {
            renderer.render(scene, camera);
          }
          
          state.animationFrameId = requestAnimationFrame(render);
        };
        render();
      }

      updateCakePosition() {
        if (!state.lastLandmarks || !cakeMesh) return;
        
        const screenX = state.palmCenter.x * window.innerWidth;
        const screenY = (1 - state.palmCenter.y) * window.innerHeight;
        
        const cakeSize = Math.max(
          CONFIG.MIN_CAKE_SIZE, 
          Math.min(CONFIG.MAX_CAKE_SIZE, state.palmSize * CONFIG.PALM_SCALE_FACTOR * 150)
        );
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ —Ç–æ—Ä—Ç
        cakeMesh.position.set(
          screenX - window.innerWidth / 2,
          screenY - window.innerHeight / 2,
          0
        );
        cakeMesh.scale.set(cakeSize, cakeSize * 0.3, cakeSize);
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ —Å–≤—ñ—á–∫—É
        if (candleMesh) {
          candleMesh.position.set(
            screenX - window.innerWidth / 2,
            (screenY - window.innerHeight / 2) + cakeSize * 0.15,
            0
          );
          candleMesh.scale.set(cakeSize * 0.1, cakeSize * 0.4, cakeSize * 0.1);
          candleMesh.visible = state.isFlameLit;
        }
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ –ø–æ–ª—É–º'—è
        if (flameMesh) {
          flameMesh.position.set(
            screenX - window.innerWidth / 2,
            (screenY - window.innerHeight / 2) + cakeSize * 0.15 + cakeSize * 0.2,
            0
          );
          flameMesh.scale.set(cakeSize * 0.05, cakeSize * 0.1, cakeSize * 0.05);
          flameMesh.visible = state.isFlameLit;
        }
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ —Å–≤—ñ—Ç–ª–æ
        if (flameLight) {
          flameLight.position.set(
            screenX - window.innerWidth / 2,
            (screenY - window.innerHeight / 2) + cakeSize * 0.15 + cakeSize * 0.2,
            0
          );
          flameLight.visible = state.isFlameLit;
        }
      }

      updateConfetti() {
        confetti = confetti.filter(p => p.life > 0);
        confetti.forEach(p => p.update());
        confettiCtx.clearRect(0, 0, elements.confettiCanvas.width, elements.confettiCanvas.height);
        confetti.forEach(p => p.draw(confettiCtx));
      }

      detectHands() {
        if (!handLandmarker || elements.video.readyState < 2) return;
        
        try {
          const predictions = handLandmarker.detectForVideo(elements.video, performance.now());
          if (predictions.landmarks && predictions.landmarks.length > 0) {
            state.handNotDetectedCount = 0;
            this.hideHandIndicator();
            
            const landmarks = predictions.landmarks[0];
            state.lastLandmarks = this.smoothLandmarks(landmarks);
            this.calculatePalmCenter(landmarks);
            
            if (!state.isCakeVisible) {
              state.isCakeVisible = true;
              cakeMesh.visible = true;
              elements.wishText.style.display = 'block';
              elements.flameStatus.style.display = 'block';
            }
            
          } else {
            state.handNotDetectedCount++;
            if (state.handNotDetectedCount > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
              this.showHandIndicator();
              this.hideCake();
              state.isCakeVisible = false;
              elements.wishText.style.display = 'none';
              elements.flameStatus.style.display = 'none';
            }
          }
        } catch (error) {
          console.error('Hand detection error:', error);
        }
      }

      calculatePalmCenter(landmarks) {
        const wrist = landmarks[0];
        const basePoints = [5, 9, 13, 17];
        
        let sumX = wrist.x;
        let sumY = wrist.y;
        
        basePoints.forEach(idx => {
          sumX += landmarks[idx].x;
          sumY += landmarks[idx].y;
        });
        
        state.palmCenter = {
          x: sumX / (basePoints.length + 1),
          y: sumY / (basePoints.length + 1)
        };
        
        const middleBase = landmarks[9];
        const distance = Math.sqrt(
          Math.pow(wrist.x - middleBase.x, 2) + 
          Math.pow(wrist.y - middleBase.y, 2)
        );
        
        state.palmSize = Math.max(0.5, Math.min(2, distance * 10));
      }

      smoothLandmarks(newLandmarks) {
        if (!state.smoothedLandmarks) {
          state.smoothedLandmarks = newLandmarks.map(lm => ({ ...lm }));
          return state.smoothedLandmarks;
        }
        
        for (let i = 0; i < newLandmarks.length; i++) {
          state.smoothedLandmarks[i].x = this.lerp(
            state.smoothedLandmarks[i].x, 
            newLandmarks[i].x, 
            CONFIG.SMOOTHING_FACTOR
          );
          state.smoothedLandmarks[i].y = this.lerp(
            state.smoothedLandmarks[i].y, 
            newLandmarks[i].y, 
            CONFIG.SMOOTHING_FACTOR
          );
        }
        
        return state.smoothedLandmarks;
      }

      lerp(start, end, factor) {
        return start * (1 - factor) + end * factor;
      }

      hideCake() {
        if (cakeMesh) cakeMesh.visible = false;
        if (candleMesh) candleMesh.visible = false;
        if (flameMesh) flameMesh.visible = false;
        if (flameLight) flameLight.visible = false;
      }

      blowOutCandle() {
        if (!state.isFlameLit) return;
        
        state.isFlameLit = false;
        if (flameMesh) flameMesh.visible = false;
        if (flameLight) flameLight.visible = false;
        if (candleMesh) candleMesh.visible = false;
        
        // –í—ñ–¥—Ç–≤–æ—Ä—é—î–º–æ –∑–≤—É–∫ –∑–∞–¥—É–≤–∞–Ω–Ω—è
        this.playBlowSound();
        
        elements.flameStatus.textContent = 'üéâ –ë–∞–∂–∞–Ω–Ω—è –∑–±—É–ª–æ—Å—è!';
        elements.flameStatus.style.backgroundColor = 'rgba(76, 175, 80, 0.9)';
        
        this.triggerConfetti();
        
        // –ß–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥–∏ –∑–∞–ø–∞–ª—é—î–º–æ —Å–≤—ñ—á–∫—É –∑–Ω–æ–≤—É
        setTimeout(() => {
          this.relightCandle();
        }, 3000);
      }

      playBlowSound() {
        if (!state.audioContext || !state.isAudioUnlocked) return;
        
        try {
          const oscillator = state.audioContext.createOscillator();
          const gainNode = state.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(state.audioContext.destination);
          
          oscillator.frequency.setValueAtTime(200, state.audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(50, state.audioContext.currentTime + 0.5);
          
          gainNode.gain.setValueAtTime(0.3, state.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.5);
          
          oscillator.start();
          oscillator.stop(state.audioContext.currentTime + 0.5);
        } catch (e) {
          console.log('Could not play blow sound:', e);
        }
      }

      relightCandle() {
        state.isFlameLit = true;
        if (candleMesh) candleMesh.visible = true;
        if (flameMesh) flameMesh.visible = true;
        if (flameLight) flameLight.visible = true;
        
        elements.flameStatus.textContent = 'üî• –ü–æ–ª—É–º\'—è –ø–∞–ª–∞—î';
        elements.flameStatus.style.backgroundColor = 'rgba(255, 107, 107, 0.9)';
      }

      triggerConfetti() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        for (let i = 0; i < 100; i++) {
          confetti.push(new ConfettiParticle(centerX, centerY));
        }
      }

      toggleMicrophone() {
        if (state.isMicActive) {
          this.stopMicrophone();
        } else {
          this.initMicrophone();
        }
      }

      showHandIndicator() {
        elements.handIndicator.classList.add('show');
      }

      hideHandIndicator() {
        elements.handIndicator.classList.remove('show');
      }

      hideLoading() {
        elements.loading.style.display = 'none';
        elements.video.style.display = 'block';
        elements.canvas.style.display = 'block';
        elements.confettiCanvas.width = window.innerWidth;
        elements.confettiCanvas.height = window.innerHeight;
      }

      handleResize() {
        if (!camera || !renderer) return;
        
        camera.left = -window.innerWidth / 2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = -window.innerHeight / 2;
        camera.updateProjectionMatrix();
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        elements.confettiCanvas.width = window.innerWidth;
        elements.confettiCanvas.height = window.innerHeight;
      }

      handleError(error) {
        console.error('App error:', error);
        elements.loading.innerHTML = `
          <div style="color: #ff4757; font-size: 24px; margin-bottom: 20px;">–ü–æ–º–∏–ª–∫–∞</div>
          <div style="color: #666; font-size: 18px; margin-bottom: 20px; line-height: 1.4;">
            ${error.message || '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è'}
          </div>
          <button id="errorRetry" style="padding: 12px 24px; background: #ff6b95; color: white; border: none; border-radius: 25px; cursor: pointer;">
            –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
          </button>
        `;
        
        document.getElementById('errorRetry').addEventListener('click', () => location.reload());
      }

      cleanup() {
        if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
        if (elements.video.srcObject) {
          elements.video.srcObject.getTracks().forEach(track => track.stop());
        }
        if (handLandmarker) handLandmarker.close();
        this.stopMicrophone();
      }
    }

    class ConfettiParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = Math.random() * -15 - 5;
        this.size = Math.random() * 6 + 4;
        this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
        this.life = 1.0;
        this.gravity = 0.4;
        this.rotation = Math.random() * Math.PI * 2;
        this.spin = (Math.random() - 0.5) * 0.3;
      }
      
      update() {
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.015;
        this.rotation += this.spin;
      }
      
      draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
      }
    }

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–æ–¥–∞—Ç–∫—É –ø—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å—Ç–æ—Ä—ñ–Ω–∫–∏
    document.addEventListener('DOMContentLoaded', () => {
      new CakeARApplication();
    });
  </script>
</body>
</html>
