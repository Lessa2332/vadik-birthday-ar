<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è | –ó–∞–¥—É–π —Å–≤—ñ—á–∫—É</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: linear-gradient(135deg, #8A2BE2 0%, #4B0082 100%);
      overflow: hidden;
      font-family: 'Arial', 'Segoe UI', system-ui, sans-serif;
      color: white;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #8A2BE2 0%, #4B0082 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
      text-align: center;
      padding: 20px;
    }
    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #FFD700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    #wishText {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #FFD700;
      padding: 15px 25px;
      border-radius: 20px;
      font-size: 1.3em;
      font-weight: bold;
      z-index: 85;
      text-align: center;
      border: 2px solid #FFD700;
      display: none;
      max-width: 90%;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    #handIndicator {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #FFD700;
      padding: 15px 25px;
      border-radius: 20px;
      border: 2px solid rgba(255, 215, 0, 0.5);
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 99;
      font-size: 17px;
      font-weight: bold;
      backdrop-filter: blur(10px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    #flameStatus {
      position: fixed;
      top: 85px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #FF4500 0%, #FF6347 100%);
      color: white;
      padding: 12px 24px;
      border-radius: 20px;
      font-size: 17px;
      z-index: 100;
      display: none;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }

    #micBtn {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 75px;
      height: 75px;
      border-radius: 50%;
      background: linear-gradient(135deg, #FF4500 0%, #FF6347 100%);
      border: 3px solid #FFD700;
      color: white;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 0 30px rgba(255, 69, 0, 0.9);
      transition: all 0.3s ease;
    }
    #micBtn:hover {
      transform: translateX(-50%) scale(1.15);
      box-shadow: 0 0 40px rgba(255, 69, 0, 1);
    }

    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); } 
    }
    @keyframes flameFlicker {
      0%, 100% { 
        transform: scale(1) translateY(0); 
        opacity: 0.95; 
      }
      33% { 
        transform: scale(1.1) translateY(-1px); 
        opacity: 1; 
      }
      66% { 
        transform: scale(0.95) translateY(1px); 
        opacity: 0.9; 
      }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div style="font-size: 1.5em; margin-bottom: 10px;">üéÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
    <p style="margin-top: 20px; color: rgba(255,255,255,0.9);">–ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="wishText">üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è —Ç–∞ –∑–∞–¥—É–π —Å–≤—ñ—á–∫—É! üí®</div>
  <div id="flameStatus">üî• –ü–æ–ª—É–º'—è –ø–∞–ª–∞—î</div>
  <div id="handIndicator">üëã –ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</div>
  <button id="micBtn">üé§</button>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    // –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è
    const CONFIG = {
      SMOOTHING_FACTOR: 0.6,
      HAND_NOT_DETECTED_THRESHOLD: 30,
      FLAME_BLOWOUT_THRESHOLD: 0.4,
      CAKE_SCALE: 0.5,
      CANDLE_HEIGHT: 0.5
    };

    // –°—Ç–∞–Ω –¥–æ–¥–∞—Ç–∫—É
    const state = {
      landmarks: null,
      isHandVisible: false,
      handFrames: 0,
      isFlameLit: true,
      isMicActive: false,
      audioContext: null,
      analyser: null,
      animationId: null,
      time: 0
    };

    // DOM –µ–ª–µ–º–µ–Ω—Ç–∏
    const elements = {
      video: document.getElementById('video'),
      canvas: document.getElementById('canvas'),
      loading: document.getElementById('loading'),
      wishText: document.getElementById('wishText'),
      flameStatus: document.getElementById('flameStatus'),
      handIndicator: document.getElementById('handIndicator'),
      micBtn: document.getElementById('micBtn')
    };

    // Three.js –∑–º—ñ–Ω–Ω—ñ
    let scene, camera, renderer;
    let cakeSprite, candle, flameGroup;
    let handLandmarker;

    class CakeARApp {
      constructor() {
        this.init();
      }

      async init() {
        try {
          await this.setupCamera();
          await this.initThreeJS();
          await this.initHandTracking();
          this.setupEventListeners();
          this.hideLoading();
          this.startAnimation();
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó:', error);
          this.showError('–ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É —Ç–∞ –¥–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏');
        }
      }

      async setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          });
          elements.video.srcObject = stream;
          await new Promise(resolve => {
            elements.video.onloadedmetadata = () => {
              elements.video.play();
              resolve();
            };
          });
        } catch (error) {
          throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏');
        }
      }

      async initThreeJS() {
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Å—Ü–µ–Ω—É
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x8A2BE2, 5, 15);
        
        // –ö–∞–º–µ—Ä–∞
        camera = new THREE.PerspectiveCamera(
          60, 
          window.innerWidth / window.innerHeight, 
          0.1, 
          1000
        );
        camera.position.set(0, 0, 5);
        
        // –†–µ–Ω–¥–µ—Ä–µ—Ä
        renderer = new THREE.WebGLRenderer({
          canvas: elements.canvas,
          alpha: true,
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        
        // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ PNG —Ç–æ—Ä—Ç–∞
        await this.loadCakeSprite();
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –≥–∞—Ä–Ω—É —Å–≤—ñ—á–∫—É –∑ –ø—Ä–∏—Ä–æ–¥–Ω–∏–º –ø–æ–ª—É–º'—è–º
        this.createBeautifulCandle();
      }

      async loadCakeSprite() {
        return new Promise((resolve) => {
          const textureLoader = new THREE.TextureLoader();
          
          textureLoader.load(
            'foto.png',
            (texture) => {
              // –°—Ç–≤–æ—Ä—é—î–º–æ —Å–ø—Ä–∞–π—Ç –∑ —Ç–µ–∫—Å—Ç—É—Ä–æ—é —Ç–æ—Ä—Ç–∞
              const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false
              });
              
              cakeSprite = new THREE.Sprite(spriteMaterial);
              cakeSprite.scale.set(3, 3, 1);
              cakeSprite.visible = false;
              scene.add(cakeSprite);
              resolve();
            },
            undefined,
            (error) => {
              console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–æ—Ç–æ:', error);
              this.createFallbackSprite();
              resolve();
            }
          );
        });
      }

      createFallbackSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // –ö—Ä–∞—Å–∏–≤–∏–π –≥—Ä–∞–¥—ñ—î–Ω—Ç –¥–ª—è —Ç–æ—Ä—Ç–∞
        const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
        gradient.addColorStop(0, '#ff9a9e');
        gradient.addColorStop(0.5, '#fad0c4');
        gradient.addColorStop(1, '#fbc2eb');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);
        
        // –î–µ–∫–æ—Ä–∞—Ü—ñ—ó
        ctx.fillStyle = 'white';
        ctx.font = 'bold 100px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üéÇ', 256, 256);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ 
          map: texture,
          transparent: true
        });
        
        cakeSprite = new THREE.Sprite(spriteMaterial);
        cakeSprite.scale.set(3, 3, 1);
        cakeSprite.visible = false;
        scene.add(cakeSprite);
      }

      createBeautifulCandle() {
        // –ì—Ä—É–ø–∞ –¥–ª—è –≤—Å—ñ—î—ó —Å–≤—ñ—á–∫–∏
        candle = new THREE.Group();
        candle.visible = false;
        scene.add(candle);
        
        // –¢–Ü–õ–û –°–í–Ü–ß–ö–ò - –≥–∞—Ä–Ω–µ, –Ω–µ —á–æ—Ä–Ω–µ!
        const candleBodyGeometry = new THREE.CylinderGeometry(0.06, 0.07, 0.4, 32);
        const candleBodyMaterial = new THREE.MeshPhongMaterial({
          color: 0xF5F5DC, // –°–≤—ñ—Ç–ª–æ-–±–µ–∂–µ–≤–∏–π –∫–æ–ª—ñ—Ä (—è–∫ —Å–ø—Ä–∞–≤–∂–Ω—è —Å–≤—ñ—á–∫–∞)
          shininess: 100,
          specular: 0x444444,
          emissive: 0x222222,
          emissiveIntensity: 0.1
        });
        const candleBody = new THREE.Mesh(candleBodyGeometry, candleBodyMaterial);
        candleBody.position.y = 0.2; // –ü—ñ–¥–Ω—ñ–º–∞—î–º–æ —Ç—Ä–æ—Ö–∏
        candle.add(candleBody);
        
        // –¢–ï–ö–°–¢–£–†–ê –°–í–Ü–ß–ö–ò (–ª–µ–≥–∫—ñ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ñ —Å–º—É–≥–∏)
        const candleStripes = new THREE.CylinderGeometry(0.061, 0.071, 0.41, 32, 1, true);
        const stripeMaterial = new THREE.MeshBasicMaterial({
          color: 0xE8E8E8,
          transparent: true,
          opacity: 0.3,
          side: THREE.DoubleSide
        });
        const stripes = new THREE.Mesh(candleStripes, stripeMaterial);
        stripes.position.y = 0.2;
        candle.add(stripes);
        
        // –ì–ù–Ü–¢ (—Å—ñ—Ä–∏–π, –∫–æ—Ä–æ—Ç–∫–∏–π)
        const wickGeometry = new THREE.CylinderGeometry(0.008, 0.008, 0.03, 8);
        const wickMaterial = new THREE.MeshPhongMaterial({
          color: 0x333333,
          emissive: 0x111111,
          emissiveIntensity: 0.2
        });
        const wick = new THREE.Mesh(wickGeometry, wickMaterial);
        wick.position.y = 0.42; // –ù–∞ —Å–∞–º–æ–º—É –≤–µ—Ä—Ö—É —Å–≤—ñ—á–∫–∏
        candle.add(wick);
        
        // –ü–û–õ–£–ú'–Ø - –ø—Ä–∏—Ä–æ–¥–Ω–µ, –Ω–µ —Ç—Ä–∏–∫—É—Ç–Ω–µ
        this.createNaturalFlame();
        
        // –°–í–Ü–¢–õ–û –í–Ü–î –ü–û–õ–£–ú'–Ø (–±–ª–∏–∂—á–µ –¥–æ —Å–≤—ñ—á–∫–∏)
        const flameLight = new THREE.PointLight(0xFFA500, 1.5, 2.5);
        flameLight.position.set(0, 0.48, 0);
        candle.add(flameLight);
      }

      createNaturalFlame() {
        // –ì—Ä—É–ø–∞ –¥–ª—è –≤—Å—å–æ–≥–æ –ø–æ–ª—É–º'—è
        flameGroup = new THREE.Group();
        flameGroup.position.y = 0.46; // –ë–õ–ò–ñ–ß–ï –¥–æ —Å–≤—ñ—á–∫–∏!
        flameGroup.visible = false;
        candle.add(flameGroup);
        
        // –û–°–ù–û–í–ù–ï –ü–û–õ–£–ú'–Ø (—è–π—Ü–µ–ø–æ–¥—ñ–±–Ω–∞ —Ñ–æ—Ä–º–∞, –Ω–µ —Ç—Ä–∏–∫—É—Ç–Ω–∞)
        const flameShape = new THREE.Shape();
        flameShape.moveTo(0, 0);
        flameShape.bezierCurveTo(0.05, 0.1, 0.04, 0.3, 0, 0.4);
        flameShape.bezierCurveTo(-0.04, 0.3, -0.05, 0.1, 0, 0);
        
        const flameGeometry = new THREE.ExtrudeGeometry(flameShape, {
            depth: 0.02,
            bevelEnabled: false,
            curveSegments: 32
        });
        flameGeometry.rotateX(Math.PI / 2);
        flameGeometry.translate(0, 0.2, 0);
        
        // –í–ù–£–¢–†–Ü–®–ù–Ñ –ü–û–õ–£–ú'–Ø (—è—Å–∫—Ä–∞–≤–æ-–∂–æ–≤—Ç–µ)
        const innerFlameMaterial = new THREE.MeshPhongMaterial({
            color: 0xFFFF00,
            emissive: 0xFFAA00,
            emissiveIntensity: 1.5,
            transparent: true,
            opacity: 0.95,
            shininess: 100
        });
        const innerFlame = new THREE.Mesh(flameGeometry, innerFlameMaterial);
        innerFlame.scale.set(1.2, 1, 1);
        flameGroup.add(innerFlame);
        
        // –°–ï–†–ï–î–ù–Ñ –ü–û–õ–£–ú'–Ø (–æ—Ä–∞–Ω–∂–µ–≤–µ)
        const middleFlameMaterial = new THREE.MeshPhongMaterial({
            color: 0xFF8800,
            emissive: 0xFF6600,
            emissiveIntensity: 1.2,
            transparent: true,
            opacity: 0.7,
            shininess: 80
        });
        const middleFlame = new THREE.Mesh(flameGeometry, middleFlameMaterial);
        middleFlame.scale.set(1.4, 1.1, 1);
        flameGroup.add(middleFlame);
        
        // –ó–û–í–ù–Ü–®–ù–Ñ –ü–û–õ–£–ú'–Ø (—á–µ—Ä–≤–æ–Ω–µ)
        const outerFlameMaterial = new THREE.MeshPhongMaterial({
            color: 0xFF3300,
            emissive: 0xFF2200,
            emissiveIntensity: 1.0,
            transparent: true,
            opacity: 0.5,
            shininess: 60
        });
        const outerFlame = new THREE.Mesh(flameGeometry, outerFlameMaterial);
        outerFlame.scale.set(1.6, 1.2, 1);
        flameGroup.add(outerFlame);
        
        // –î–ò–ú (–¥—É–∂–µ –ª–µ–≥–∫–∏–π, –Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∏–π)
        const smokeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
        const smokeMaterial = new THREE.MeshBasicMaterial({
            color: 0x888888,
            transparent: true,
            opacity: 0.2
        });
        const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
        smoke.position.y = 0.25;
        flameGroup.add(smoke);
      }

      async initHandTracking() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });
      }

      setupEventListeners() {
        elements.micBtn.addEventListener('click', () => this.toggleMicrophone());
        window.addEventListener('resize', () => this.onWindowResize());
      }

      toggleMicrophone() {
        if (state.isMicActive) {
          this.stopMicrophone();
          elements.micBtn.style.background = 'linear-gradient(135deg, #FF4500 0%, #FF6347 100%)';
        } else {
          this.startMicrophone();
          elements.micBtn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        }
      }

      async startMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: true
          });
          
          state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = state.audioContext.createMediaStreamSource(stream);
          state.analyser = state.audioContext.createAnalyser();
          state.analyser.fftSize = 256;
          state.analyser.smoothingTimeConstant = 0.2;
          source.connect(state.analyser);
          
          state.isMicActive = true;
          
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞:', error);
          alert('–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞ –¥–ª—è –∑–∞–¥—É–≤–∞–Ω–Ω—è —Å–≤—ñ—á–∫–∏ üé§');
        }
      }

      stopMicrophone() {
        if (state.audioContext) {
          state.audioContext.close();
        }
        state.analyser = null;
        state.isMicActive = false;
      }

      checkMicrophoneVolume() {
        if (!state.isMicActive || !state.analyser || !state.isFlameLit) return false;
        
        const dataArray = new Uint8Array(state.analyser.frequencyBinCount);
        state.analyser.getByteFrequencyData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        const volume = average / 255;
        
        return volume > CONFIG.FLAME_BLOWOUT_THRESHOLD;
      }

      startAnimation() {
        const animate = () => {
          state.time += 0.016;
          this.update();
          this.render();
          state.animationId = requestAnimationFrame(animate);
        };
        animate();
      }

      update() {
        this.detectHand();
        
        if (state.landmarks && state.isHandVisible) {
          this.updatePosition();
          
          if (!cakeSprite.visible) {
            cakeSprite.visible = true;
            candle.visible = state.isFlameLit;
            flameGroup.visible = state.isFlameLit;
            elements.wishText.style.display = 'block';
            elements.flameStatus.style.display = 'block';
            elements.handIndicator.style.display = 'none';
          }
        } else {
          if (cakeSprite.visible) {
            cakeSprite.visible = false;
            candle.visible = false;
            flameGroup.visible = false;
            elements.wishText.style.display = 'none';
            elements.flameStatus.style.display = 'none';
          }
          
          if (state.handFrames > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
            elements.handIndicator.style.display = 'flex';
          }
        }
        
        // –ê–ù–Ü–ú–ê–¶–Ü–Ø –ü–û–õ–£–ú'–Ø (–ø—Ä–∏—Ä–æ–¥–Ω–∞)
        if (state.isFlameLit && flameGroup && flameGroup.visible) {
          this.animateFlame();
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∑–∞–¥—É–≤–∞–Ω–Ω—è
        if (this.checkMicrophoneVolume() && state.isFlameLit) {
          this.blowOutCandle();
        }
      }

      detectHand() {
        if (!handLandmarker || elements.video.readyState < 2) return;
        
        try {
          const results = handLandmarker.detectForVideo(elements.video, performance.now());
          
          if (results.landmarks && results.landmarks.length > 0) {
            state.landmarks = results.landmarks[0];
            state.isHandVisible = true;
            state.handFrames = 0;
          } else {
            state.landmarks = null;
            state.isHandVisible = false;
            state.handFrames++;
          }
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ä—É–∫–∏:', error);
        }
      }

      updatePosition() {
        if (!state.landmarks) return;
        
        // –¶–µ–Ω—Ç—Ä –¥–æ–ª–æ–Ω—ñ
        const points = [0, 5, 9, 13, 17];
        let centerX = 0, centerY = 0;
        for (const idx of points) {
          centerX += state.landmarks[idx].x;
          centerY += state.landmarks[idx].y;
        }
        centerX /= points.length;
        centerY /= points.length;
        
        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        const x = (centerX - 0.5) * 8;
        const y = (0.5 - centerY) * 6;
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ —Ç–æ—Ä—Ç
        if (cakeSprite) {
          cakeSprite.position.set(x, y - 0.5, 0);
          cakeSprite.lookAt(camera.position);
        }
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ —Å–≤—ñ—á–∫—É –ù–ê–î —Ç–æ—Ä—Ç–æ–º
        if (candle) {
          candle.position.set(x, y + 0.5, 0); // –í–∏—â–µ –Ω–∞ 0.5 –æ–¥–∏–Ω–∏—Ü—ñ
          candle.lookAt(camera.position);
        }
      }

      animateFlame() {
        if (!flameGroup) return;
        
        const time = state.time;
        
        // –†–Ü–ó–ù–Ü –ß–ê–°–¢–û–¢–ò –î–õ–Ø –ü–†–ò–†–û–î–ù–û–°–¢–Ü
        const scale1 = 1 + Math.sin(time * 15) * 0.12;
        const scale2 = 1 + Math.sin(time * 11 + 1.5) * 0.1;
        const scale3 = 1 + Math.sin(time * 8 + 2.5) * 0.08;
        
        // –í–ï–†–¢–ò–ö–ê–õ–¨–ù–ï –ö–û–õ–ò–í–ê–ù–ù–Ø
        const offsetY = Math.sin(time * 7) * 0.03;
        
        // –û–ë–ï–†–¢–ê–ù–ù–Ø –î–õ–Ø –ï–§–ï–ö–¢–£ "–¢–ê–ù–¶–Æ –í–û–ì–ù–Æ"
        const rotationZ = Math.sin(time * 5) * 0.08;
        
        // –û–ù–û–í–õ–Æ–Ñ–ú–û –ö–û–ñ–ï–ù –®–ê–†
        flameGroup.children.forEach((layer, index) => {
          if (index < 3) { // –ü–µ—Ä—à—ñ —Ç—Ä–∏ - —à–∞—Ä–∏ –ø–æ–ª—É–º'—è
            const scale = index === 0 ? scale1 : index === 1 ? scale2 : scale3;
            layer.scale.set(scale, scale * 0.9, scale);
            layer.position.y = offsetY;
          }
        });
        
        // –ó–∞–≥–∞–ª—å–Ω–µ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è –≥—Ä—É–ø–∏
        flameGroup.rotation.z = rotationZ;
        
        // –ê–ù–Ü–ú–ê–¶–Ü–Ø –ö–û–õ–¨–û–†–£
        const colorShift = Math.sin(time * 3) * 0.1;
        if (flameGroup.children[0]) {
          const innerMaterial = flameGroup.children[0].material;
          const hue = 0.15 + colorShift; // –í—ñ–¥ –∂–æ–≤—Ç–æ–≥–æ –¥–æ –æ—Ä–∞–Ω–∂–µ–≤–æ–≥–æ
          innerMaterial.color.setHSL(hue, 1, 0.6);
        }
      }

      blowOutCandle() {
        state.isFlameLit = false;
        flameGroup.visible = false;
        
        // –ï–§–ï–ö–¢ –ó–ê–î–£–í–ê–ù–ù–Ø
        elements.flameStatus.textContent = 'üí® –°–≤—ñ—á–∫–∞ –∑–∞–¥—É—Ç–∞! üéâ';
        elements.flameStatus.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        elements.flameStatus.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
        
        elements.wishText.textContent = 'üéâ –ë–∞–∂–∞–Ω–Ω—è –∑–±—É–¥–µ—Ç—å—Å—è! ‚ú®';
        elements.wishText.style.color = '#4CAF50';
        
        // –°–¢–í–û–†–Æ–Ñ–ú–û –ï–§–ï–ö–¢ –î–ò–ú–£
        this.createSmokeEffect();
        
        // –ó–í–£–ö –ó–ê–î–£–í–ê–ù–ù–Ø
        this.playBlowSound();
        
        // –ß–ï–†–ï–ó 4 –°–ï–ö–£–ù–î–ò –ó–ù–û–í–£ –ó–ê–ü–ê–õ–Æ–Ñ–ú–û
        setTimeout(() => {
          this.relightCandle();
        }, 4000);
      }

      createSmokeEffect() {
        // –ü—Ä–æ—Å—Ç–∏–π –µ—Ñ–µ–∫—Ç –¥–∏–º—É —á–µ—Ä–µ–∑ –∑–º—ñ–Ω—É —Ç–µ–∫—Å—Ç—É
        const originalText = elements.wishText.textContent;
        let smokeCount = 0;
        const smokeInterval = setInterval(() => {
          smokeCount++;
          elements.wishText.textContent = 'üí® '.repeat(smokeCount) + '–î–∏–º–µ—Ü—å...';
          if (smokeCount >= 3) {
            clearInterval(smokeInterval);
            elements.wishText.textContent = originalText;
          }
        }, 300);
      }

      playBlowSound() {
        if (!state.audioContext) return;
        
        try {
          const oscillator = state.audioContext.createOscillator();
          const gainNode = state.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(state.audioContext.destination);
          
          oscillator.frequency.setValueAtTime(300, state.audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(50, state.audioContext.currentTime + 0.8);
          
          gainNode.gain.setValueAtTime(0.4, state.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.001, state.audioContext.currentTime + 0.8);
          
          oscillator.start();
          oscillator.stop(state.audioContext.currentTime + 0.8);
        } catch (e) {
          // –Ü–≥–Ω–æ—Ä—É—î–º–æ –ø–æ–º–∏–ª–∫–∏ –∑–≤—É–∫—É
        }
      }

      relightCandle() {
        state.isFlameLit = true;
        flameGroup.visible = true;
        
        elements.flameStatus.textContent = 'üî• –ü–æ–ª—É–º\'—è –ø–∞–ª–∞—î';
        elements.flameStatus.style.background = 'linear-gradient(135deg, #FF4500 0%, #FF6347 100%)';
        elements.flameStatus.style.boxShadow = '0 0 20px rgba(255, 69, 0, 0.8)';
        
        elements.wishText.textContent = 'üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è —Ç–∞ –∑–∞–¥—É–π —Å–≤—ñ—á–∫—É! üí®';
        elements.wishText.style.color = '#FFD700';
      }

      render() {
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      onWindowResize() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      hideLoading() {
        elements.loading.style.display = 'none';
        elements.video.style.display = 'block';
        elements.canvas.style.display = 'block';
        elements.handIndicator.style.display = 'flex';
      }

      showError(message) {
        elements.loading.innerHTML = `
          <div style="color: #ff6b6b; font-size: 28px; margin-bottom: 20px;">üòï</div>
          <div style="font-size: 18px; margin-bottom: 20px;">${message}</div>
          <button onclick="location.reload()" style="padding: 14px 28px; background: linear-gradient(135deg, #FF4500 0%, #FF6347 100%); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px;">
            –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
          </button>
        `;
      }

      cleanup() {
        if (state.animationId) cancelAnimationFrame(state.animationId);
        if (elements.video.srcObject) {
          elements.video.srcObject.getTracks().forEach(track => track.stop());
        }
        if (handLandmarker) handLandmarker.close();
        this.stopMicrophone();
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      const app = new CakeARApp();
      window.addEventListener('beforeunload', () => app.cleanup());
    });
  </script>
</body>
</html>
