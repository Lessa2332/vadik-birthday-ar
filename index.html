<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è | –ó–∞–¥—É–π —Å–≤—ñ—á–∫—É</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      overflow: hidden;
      font-family: 'Arial', 'Segoe UI', system-ui, sans-serif;
      color: #333;
    }
    #video, #canvas, #confettiCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }
    #confettiCanvas { z-index: 3; pointer-events: none; }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #ff6b95;
      text-align: center;
      padding: 20px;
    }
    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 107, 149, 0.3);
      border-top: 4px solid #ff6b95;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    #wishText {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      color: #ff6b95;
      padding: 15px 25px;
      border-radius: 20px;
      font-size: 1.3em;
      font-weight: bold;
      z-index: 85;
      text-align: center;
      border: 3px solid #ffb6c1;
      display: none;
      max-width: 90%;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    }

    #handIndicator {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      color: #ff6b95;
      padding: 12px 20px;
      border-radius: 20px;
      border: 2px solid rgba(255, 182, 193, 0.5);
      display: none;
      align-items: center;
      gap: 10px;
      z-index: 99;
      font-size: 16px;
      font-weight: bold;
    }

    #flameStatus {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 107, 107, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      z-index: 100;
      display: none;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    #micBtn {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 3px solid #ff6b95;
      color: #ff6b95;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 8px 25px rgba(255, 107, 149, 0.3);
    }

    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); } 
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div>üéÇ –ì–æ—Ç—É—î–º–æ —Ç–æ—Ä—Ç...</div>
    <p style="margin-top: 20px; color: #666;">–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>
  <canvas id="confettiCanvas"></canvas>

  <div id="wishText">üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è —Ç–∞ –∑–∞–¥—É–π —Å–≤—ñ—á–∫—É! üí®</div>
  <div id="flameStatus">üî• –ü–æ–ª—É–º'—è –ø–∞–ª–∞—î</div>
  <div id="handIndicator">üëã –ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</div>
  <button id="micBtn">üé§</button>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    // –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è
    const CONFIG = {
      SMOOTHING_FACTOR: 0.5,
      HAND_NOT_DETECTED_THRESHOLD: 30,
      CAKE_SCALE: 0.15,
      CANDLE_HEIGHT: 0.2,
      FLAME_BLOWOUT_THRESHOLD: 0.4
    };

    // –°—Ç–∞–Ω –¥–æ–¥–∞—Ç–∫—É
    const state = {
      landmarks: null,
      isHandVisible: false,
      handFrames: 0,
      isFlameLit: true,
      isMicActive: false,
      audioContext: null,
      analyser: null,
      animationId: null
    };

    // DOM –µ–ª–µ–º–µ–Ω—Ç–∏
    const elements = {
      video: document.getElementById('video'),
      canvas: document.getElementById('canvas'),
      confettiCanvas: document.getElementById('confettiCanvas'),
      loading: document.getElementById('loading'),
      wishText: document.getElementById('wishText'),
      flameStatus: document.getElementById('flameStatus'),
      handIndicator: document.getElementById('handIndicator'),
      micBtn: document.getElementById('micBtn')
    };

    // Three.js –∑–º—ñ–Ω–Ω—ñ
    let scene, camera, renderer;
    let cake, candle, flame;
    let handLandmarker;

    // –ö–ª–∞—Å –¥–æ–¥–∞—Ç–∫—É
    class CakeARApp {
      constructor() {
        this.init();
      }

      async init() {
        try {
          await this.setupCamera();
          await this.initThreeJS();
          await this.initHandTracking();
          this.setupEventListeners();
          this.hideLoading();
          this.startAnimation();
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó:', error);
          this.showError('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–ø—É—Å—Ç–∏—Ç–∏ –¥–æ–¥–∞—Ç–æ–∫. –°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É.');
        }
      }

      async setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          });
          elements.video.srcObject = stream;
          await new Promise(resolve => {
            elements.video.onloadedmetadata = () => {
              elements.video.play();
              resolve();
            };
          });
        } catch (error) {
          throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏');
        }
      }

      async initThreeJS() {
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Å—Ü–µ–Ω—É
        scene = new THREE.Scene();
        
        // –ö–∞–º–µ—Ä–∞, —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î —Ä–æ–∑–º—ñ—Ä—É –µ–∫—Ä–∞–Ω—É
        camera = new THREE.PerspectiveCamera(
          60, 
          window.innerWidth / window.innerHeight, 
          0.1, 
          1000
        );
        camera.position.set(0, 0, 5);
        
        // –†–µ–Ω–¥–µ—Ä–µ—Ä
        renderer = new THREE.WebGLRenderer({
          canvas: elements.canvas,
          alpha: true,
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–æ—Ä—Ç
        this.createCake();
      }

      createCake() {
        // –û—Å–Ω–æ–≤–∞ —Ç–æ—Ä—Ç–∞ (—Ü–∏–ª—ñ–Ω–¥—Ä)
        const cakeGeometry = new THREE.CylinderGeometry(1, 1.2, 0.4, 32);
        const cakeMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xf8a5c2,
          shininess: 30
        });
        cake = new THREE.Mesh(cakeGeometry, cakeMaterial);
        cake.position.y = -1;
        cake.visible = false;
        scene.add(cake);
        
        // –°–≤—ñ—á–∫–∞
        const candleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 16);
        const candleMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        candle = new THREE.Mesh(candleGeometry, candleMaterial);
        candle.position.set(0, 0.2, 0);
        candle.visible = false;
        cake.add(candle);
        
        // –ü–æ–ª—É–º'—è
        const flameGeometry = new THREE.ConeGeometry(0.06, 0.15, 16);
        const flameMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xff5500,
          emissive: 0xff3300,
          emissiveIntensity: 0.5,
          transparent: true
        });
        flame = new THREE.Mesh(flameGeometry, flameMaterial);
        flame.position.set(0, 0.35, 0);
        flame.visible = false;
        cake.add(flame);
        
        // –°–≤—ñ—Ç–ª–æ –≤—ñ–¥ –ø–æ–ª—É–º'—è
        const flameLight = new THREE.PointLight(0xff5500, 1, 2);
        flameLight.position.set(0, 0.35, 0);
        cake.add(flameLight);
      }

      async initHandTracking() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });
      }

      setupEventListeners() {
        // –ö–Ω–æ–ø–∫–∞ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞
        elements.micBtn.addEventListener('click', () => this.toggleMicrophone());
        
        // –ê–¥–∞–ø—Ç–∞—Ü—ñ—è –¥–æ —Ä–æ–∑–º—ñ—Ä—É –≤—ñ–∫–Ω–∞
        window.addEventListener('resize', () => this.onWindowResize());
      }

      toggleMicrophone() {
        if (state.isMicActive) {
          this.stopMicrophone();
        } else {
          this.startMicrophone();
        }
      }

      async startMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            }
          });
          
          state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = state.audioContext.createMediaStreamSource(stream);
          state.analyser = state.audioContext.createAnalyser();
          state.analyser.fftSize = 256;
          source.connect(state.analyser);
          
          state.isMicActive = true;
          elements.micBtn.style.background = '#ff6b95';
          elements.micBtn.style.color = 'white';
          
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞:', error);
          alert('–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞');
        }
      }

      stopMicrophone() {
        if (state.audioContext) {
          state.audioContext.close();
          state.audioContext = null;
        }
        state.analyser = null;
        state.isMicActive = false;
        elements.micBtn.style.background = '';
        elements.micBtn.style.color = '';
      }

      checkMicrophoneVolume() {
        if (!state.isMicActive || !state.analyser || !state.isFlameLit) return false;
        
        const dataArray = new Uint8Array(state.analyser.frequencyBinCount);
        state.analyser.getByteFrequencyData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        
        return average / 255 > CONFIG.FLAME_BLOWOUT_THRESHOLD;
      }

      startAnimation() {
        const animate = () => {
          this.update();
          this.render();
          state.animationId = requestAnimationFrame(animate);
        };
        animate();
      }

      update() {
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ –ø–æ–ª–æ–∂–µ–Ω–Ω—è —Ä—É–∫–∏
        this.detectHand();
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –ø–æ–ª–æ–∂–µ–Ω–Ω—è —Ç–æ—Ä—Ç–∞
        if (state.landmarks && state.isHandVisible) {
          this.updateCakePosition();
          
          if (!cake.visible) {
            cake.visible = true;
            candle.visible = state.isFlameLit;
            flame.visible = state.isFlameLit;
            elements.wishText.style.display = 'block';
            elements.flameStatus.style.display = 'block';
            elements.handIndicator.style.display = 'none';
          }
        } else {
          if (cake.visible) {
            cake.visible = false;
            elements.wishText.style.display = 'none';
            elements.flameStatus.style.display = 'none';
          }
          
          if (state.handFrames > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
            elements.handIndicator.style.display = 'flex';
          }
        }
        
        // –ê–Ω—ñ–º–∞—Ü—ñ—è –ø–æ–ª—É–º'—è
        if (state.isFlameLit && flame.visible) {
          const time = Date.now() * 0.001;
          flame.scale.x = flame.scale.y = 1 + Math.sin(time * 10) * 0.1;
          flame.position.y = 0.35 + Math.sin(time * 8) * 0.02;
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –∑–∞–¥—É–ª–∏ —Å–≤—ñ—á–∫—É
        if (this.checkMicrophoneVolume() && state.isFlameLit) {
          this.blowOutCandle();
        }
      }

      detectHand() {
        if (!handLandmarker || elements.video.readyState < 2) return;
        
        try {
          const results = handLandmarker.detectForVideo(elements.video, performance.now());
          
          if (results.landmarks && results.landmarks.length > 0) {
            state.landmarks = results.landmarks[0];
            state.isHandVisible = true;
            state.handFrames = 0;
          } else {
            state.landmarks = null;
            state.isHandVisible = false;
            state.handFrames++;
          }
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ä—É–∫–∏:', error);
        }
      }

      updateCakePosition() {
        if (!state.landmarks || !cake) return;
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ü–µ–Ω—Ç—Ä –¥–æ–ª–æ–Ω—ñ (—Å–µ—Ä–µ–¥–Ω—î –º—ñ–∂ –∑–∞–ø'—è—Å—Ç—è–º —Ç–∞ –æ—Å–Ω–æ–≤–∞–º–∏ –ø–∞–ª—å—Ü—ñ–≤)
        const wrist = state.landmarks[0];
        const indexBase = state.landmarks[5];
        const middleBase = state.landmarks[9];
        
        const centerX = (wrist.x + indexBase.x + middleBase.x) / 3;
        const centerY = (wrist.y + indexBase.y + middleBase.y) / 3;
        
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ Three.js
        // –ï–∫—Ä–∞–Ω–Ω—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ (0-1) -> Three.js –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ (-1 –¥–æ 1)
        const x = (centerX - 0.5) * 2;
        const y = (0.5 - centerY) * 2; // –Ü–Ω–≤–µ—Ä—Ç—É—î–º–æ Y
        
        // –ú–∞—Å—à—Ç–∞–±—É—î–º–æ –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –≤–∏–≥–ª—è–¥—É
        cake.position.x = x * 3;
        cake.position.y = y * 2 - 1; // –ó—Å—É–≤–∞—î–º–æ —Ç—Ä–æ—Ö–∏ –Ω–∏–∂—á–µ
        cake.position.z = 0;
        
        // –û–±–µ—Ä—Ç–∞—î–º–æ —Ç–æ—Ä—Ç –¥–æ –∫–∞–º–µ—Ä–∏
        cake.lookAt(camera.position);
      }

      blowOutCandle() {
        state.isFlameLit = false;
        candle.visible = false;
        flame.visible = false;
        
        // –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç—É—Å
        elements.flameStatus.textContent = 'üéâ –ë–∞–∂–∞–Ω–Ω—è –∑–±—É–ª–æ—Å—è!';
        elements.flameStatus.style.background = 'rgba(76, 175, 80, 0.9)';
        
        // –ó–∞–ø—É—Å–∫–∞—î–º–æ –∫–æ–Ω—Ñ–µ—Ç—ñ
        this.createConfetti();
        
        // –ß–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥–∏ –∑–∞–ø–∞–ª—é—î–º–æ –∑–Ω–æ–≤—É
        setTimeout(() => {
          this.relightCandle();
        }, 3000);
      }

      relightCandle() {
        state.isFlameLit = true;
        candle.visible = true;
        flame.visible = true;
        
        elements.flameStatus.textContent = 'üî• –ü–æ–ª—É–º\'—è –ø–∞–ª–∞—î';
        elements.flameStatus.style.background = 'rgba(255, 107, 107, 0.9)';
      }

      createConfetti() {
        const ctx = elements.confettiCanvas.getContext('2d');
        const particles = [];
        const colors = ['#ff6b95', '#ffd166', '#06d6a0', '#118ab2', '#ef476f'];
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ —á–∞—Å—Ç–∫–∏ –∫–æ–Ω—Ñ–µ—Ç—ñ
        for (let i = 0; i < 100; i++) {
          particles.push({
            x: Math.random() * elements.confettiCanvas.width,
            y: Math.random() * elements.confettiCanvas.height,
            size: Math.random() * 10 + 5,
            color: colors[Math.floor(Math.random() * colors.length)],
            speedX: Math.random() * 6 - 3,
            speedY: Math.random() * -10 - 5,
            gravity: 0.2,
            opacity: 1
          });
        }
        
        // –ê–Ω—ñ–º–∞—Ü—ñ—è –∫–æ–Ω—Ñ–µ—Ç—ñ
        let frames = 0;
        const animateConfetti = () => {
          ctx.clearRect(0, 0, elements.confettiCanvas.width, elements.confettiCanvas.height);
          
          for (let particle of particles) {
            particle.speedY += particle.gravity;
            particle.x += particle.speedX;
            particle.y += particle.speedY;
            particle.opacity -= 0.01;
            
            ctx.save();
            ctx.globalAlpha = particle.opacity;
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
          
          frames++;
          if (frames < 100) {
            requestAnimationFrame(animateConfetti);
          }
        };
        
        animateConfetti();
      }

      render() {
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      onWindowResize() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          
          // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä canvas –¥–ª—è –∫–æ–Ω—Ñ–µ—Ç—ñ
          elements.confettiCanvas.width = window.innerWidth;
          elements.confettiCanvas.height = window.innerHeight;
        }
      }

      hideLoading() {
        elements.loading.style.display = 'none';
        elements.video.style.display = 'block';
        elements.canvas.style.display = 'block';
        elements.confettiCanvas.width = window.innerWidth;
        elements.confettiCanvas.height = window.innerHeight;
        elements.handIndicator.style.display = 'flex';
      }

      showError(message) {
        elements.loading.innerHTML = `
          <div style="color: #ff4757; font-size: 24px; margin-bottom: 20px;">–ü–æ–º–∏–ª–∫–∞</div>
          <div style="color: #666; margin-bottom: 20px;">${message}</div>
          <button onclick="location.reload()" style="padding: 12px 24px; background: #ff6b95; color: white; border: none; border-radius: 25px; cursor: pointer;">
            –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
          </button>
        `;
      }

      cleanup() {
        if (state.animationId) {
          cancelAnimationFrame(state.animationId);
        }
        if (elements.video.srcObject) {
          elements.video.srcObject.getTracks().forEach(track => track.stop());
        }
        if (handLandmarker) {
          handLandmarker.close();
        }
        this.stopMicrophone();
      }
    }

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–∏
    window.addEventListener('DOMContentLoaded', () => {
      const app = new CakeARApp();
      
      // –û—á–∏—â–µ–Ω–Ω—è –ø—Ä–∏ –∑–∞–∫—Ä–∏—Ç—Ç—ñ
      window.addEventListener('beforeunload', () => app.cleanup());
    });
  </script>
</body>
</html>
